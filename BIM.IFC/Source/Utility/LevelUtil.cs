//
// BIM IFC library: this library works with Autodesk(R) Revit(R) to export IFC files containing model geometry.
// Copyright (C) 2011  Autodesk, Inc.
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Autodesk.Revit.DB;
using Autodesk.Revit.DB.IFC;

namespace BIM.IFC.Utility
{
    /// <summary>
    /// Provides static methods for level related manipulations.
    /// </summary>
    class LevelUtil
    {
        /// <summary>
        /// Checks if view is generated by the level.
        /// </summary>
        /// <param name="view">
        /// The view.
        /// </param>
        /// <param name="level">
        /// The level.
        /// </param>
        /// <returns>
        /// True if the view is generated by the level, false otherwise.
        /// </returns>
        public static bool IsViewGeneratedByLevel(View view, Level level)
        {
            Level genLevel = view.GenLevel;
            if (genLevel == null)
                return false;

            return genLevel.Id == level.Id;
        }

        /// <summary>
        /// Checks if level has views.
        /// </summary>
        /// <param name="level">
        /// The level.
        /// </param>
        /// <returns>
        /// True if the level has views generated, false otherwise.
        /// </returns>
        public static bool LevelHasViews(Level level)
        {
            if (level == null)
                return false;
            FilteredElementCollector viewCollector = new FilteredElementCollector(level.Document);
            viewCollector.OfClass(typeof(View));
            Func<View, bool> viewIsNonTemplateAndGeneratedByLevel = view => !view.IsTemplate && IsViewGeneratedByLevel(view, level);

            return viewCollector.Cast<View>().FirstOrDefault<View>(viewIsNonTemplateAndGeneratedByLevel) != null;
        }

        /// <summary>
        /// Gets offset of non-storey level.
        /// </summary>
        /// <param name="exporterIFC">
        /// The ExporterIFC object.
        /// </param>
        /// <param name="level">
        /// The level.
        /// </param>
        /// <returns>
        /// The offset.
        /// </returns>
        public static double GetNonStoryLevelOffsetIfAny(ExporterIFC exporterIFC, Level level)
        {
            if ((level == null) || !LevelHasViews(level))
                return 0.0;
            Document document = level.Document;

            const double veryNegativeHeight = -1000000000;
            double levelHeight = level.Elevation;
            double prevHeight = veryNegativeHeight;

            IDictionary<ElementId, IFCLevelInfo> storeys = exporterIFC.GetLevelInfos();
            foreach (KeyValuePair<ElementId, IFCLevelInfo> storey in storeys)
            {
                double currentHeight = storey.Value.Elevation;
                if (currentHeight < levelHeight + MathUtil.Eps() && currentHeight > prevHeight)
                    prevHeight = currentHeight;
            }

            if (prevHeight > veryNegativeHeight)
                return levelHeight - prevHeight;
            else
                return 0.0;
        }

        /// <summary>
        /// Gets level extension.
        /// </summary>
        /// <remarks>
        /// When we are splitting columns (or walls) by level, we allow for a certain amount of overflow into the next level.
        /// This has been set (somewhat arbitrarily) at 10cm.
        /// </remarks>
        /// <returns>
        /// The level extension.
        /// </returns>
        public static double GetLevelExtension()
        {
            // 10cm, in feet.
            return 10.0 / (12.0 * 2.54);
        }

        /// <summary>
        /// Creates a list of ranges to split an element.
        /// </summary>
        /// <remarks>
        /// We may need to split an element (e.g. column) into parts by level.
        /// </remarks>
        /// <param name="exporterIFC">
        /// The ExporterIFC object.
        /// </param>
        /// <param name="exportType">
        /// The export type.
        /// </param>
        /// <param name="element">
        /// The element.
        /// </param>
        /// <param name="levels">
        /// The levels to split the element.
        /// </param>
        /// <param name="ranges">
        /// The ranges to split the element.
        /// </param>
        public static void CreateSplitLevelRangesForElement(ExporterIFC exporterIFC, IFCExportType exportType, Element elem,
            out IList<ElementId> levels, out IList<UV> ranges)
        {
            // If we are exporting a column, we may need to split it into parts by level.  Create a list of ranges.
            levels = new List<ElementId>();
            ranges = new List<UV>();
            double extension = GetLevelExtension();

            if ((exportType == IFCExportType.ExportColumnType) && (exporterIFC.WallAndColumnSplitting))
            {
                BoundingBoxXYZ boundingBox = elem.get_BoundingBox(null);
                {
                    UV zSpan = new UV(boundingBox.Min.Z, boundingBox.Max.Z);
                    if (zSpan.U < zSpan.V)
                    {
                        IDictionary<ElementId, IFCLevelInfo> storeys = exporterIFC.GetLevelInfos();
                        foreach (KeyValuePair<ElementId, IFCLevelInfo> storey in storeys)
                        {
                            IFCLevelInfo levelInfo = storey.Value;
                            // endBelowLevel 
                            if (zSpan.V < levelInfo.Elevation + extension)
                                continue;
                            // startAboveLevel
                            if ((!MathUtil.IsAlmostZero(levelInfo.DistanceToNextLevel)) &&
                               (zSpan.U > levelInfo.Elevation + levelInfo.DistanceToNextLevel - extension))
                                continue;

                            bool startBelowLevel = (zSpan.U < levelInfo.Elevation - extension);
                            bool endAboveLevel = ((!MathUtil.IsAlmostZero(levelInfo.DistanceToNextLevel)) &&
                               (zSpan.V > levelInfo.Elevation + levelInfo.DistanceToNextLevel + extension));
                            if (!startBelowLevel && !endAboveLevel)
                                break;

                            UV currentSpan = new UV(
                               startBelowLevel ? levelInfo.Elevation : zSpan.U,
                               endAboveLevel ? (levelInfo.Elevation + levelInfo.DistanceToNextLevel) : zSpan.V);
                            ranges.Add(currentSpan);
                            levels.Add(storey.Key);
                        }
                    }
                }
            }
        }
    }
}
